const std = @import("std");
const context = @import("../../core/context.zig");
const registry = @import("../../core/registry.zig");
const io = @import("../../core/io.zig");

/// Built-in .gitignore templates.
const templates = struct {
    const go =
        \\# Binaries
        \\*.exe
        \\*.exe~
        \\*.dll
        \\*.so
        \\*.dylib
        \\
        \\# Test binary
        \\*.test
        \\
        \\# Output
        \\/bin/
        \\/dist/
        \\
        \\# Go workspace
        \\go.work
        \\go.work.sum
        \\
        \\# Dependency directory
        \\vendor/
        \\
    ;

    const node =
        \\node_modules/
        \\npm-debug.log*
        \\yarn-debug.log*
        \\yarn-error.log*
        \\.pnpm-debug.log*
        \\
        \\# Build output
        \\dist/
        \\build/
        \\.next/
        \\.nuxt/
        \\
        \\# Environment
        \\.env
        \\.env.local
        \\.env.*.local
        \\
        \\# Coverage
        \\coverage/
        \\
    ;

    const python =
        \\__pycache__/
        \\*.py[cod]
        \\*$py.class
        \\
        \\# Virtual environments
        \\venv/
        \\.venv/
        \\env/
        \\.env/
        \\
        \\# Distribution
        \\dist/
        \\build/
        \\*.egg-info/
        \\*.egg
        \\
        \\# IDE
        \\.idea/
        \\.vscode/
        \\
        \\# Testing
        \\.pytest_cache/
        \\.coverage
        \\htmlcov/
        \\
    ;

    const rust =
        \\# Generated by Cargo
        \\/target/
        \\Cargo.lock
        \\
        \\# Backup files
        \\**/*.rs.bk
        \\
        \\# MSVC Windows builds
        \\*.pdb
        \\
    ;

    const zig =
        \\# Zig build artifacts
        \\zig-out/
        \\.zig-cache/
        \\zig-cache/
        \\
        \\# Object files
        \\*.o
        \\*.d
        \\
    ;

    const macos =
        \\.DS_Store
        \\.AppleDouble
        \\.LSOverride
        \\
        \\# Thumbnails
        \\._*
        \\
        \\# Files on external disk
        \\.Spotlight-V100
        \\.Trashes
        \\
    ;

    const linux =
        \\*~
        \\.fuse_hidden*
        \\.directory
        \\.Trash-*
        \\.nfs*
        \\
    ;

    const windows =
        \\Thumbs.db
        \\Thumbs.db:encryptable
        \\ehthumbs.db
        \\ehthumbs_vista.db
        \\
        \\# Folder config
        \\[Dd]esktop.ini
        \\
        \\# Recycle Bin
        \\$RECYCLE.BIN/
        \\
        \\# Shortcuts
        \\*.lnk
        \\
    ;

    const vscode =
        \\.vscode/*
        \\!.vscode/settings.json
        \\!.vscode/tasks.json
        \\!.vscode/launch.json
        \\!.vscode/extensions.json
        \\*.code-workspace
        \\.history/
        \\
    ;

    const jetbrains =
        \\.idea/
        \\*.iml
        \\*.iws
        \\*.ipr
        \\out/
        \\
    ;
};

/// Map template name to content.
fn getTemplate(name: []const u8) ?[]const u8 {
    const map = .{
        .{ "go", templates.go },
        .{ "node", templates.node },
        .{ "python", templates.python },
        .{ "rust", templates.rust },
        .{ "zig", templates.zig },
        .{ "macos", templates.macos },
        .{ "linux", templates.linux },
        .{ "windows", templates.windows },
        .{ "vscode", templates.vscode },
        .{ "jetbrains", templates.jetbrains },
    };

    inline for (map) |entry| {
        if (std.mem.eql(u8, name, entry[0])) {
            return entry[1];
        }
    }
    return null;
}

const available_templates = "go, node, python, rust, zig, macos, linux, windows, vscode, jetbrains";

/// Entry point for the gitignore command.
pub fn execute(ctx: context.Context, _: ?[]const u8) anyerror!void {
    const input = try io.getInput(ctx);
    if (input) |inp| {
        defer inp.deinit(ctx.allocator);
        if (inp.data.len == 0) {
            const writer = ctx.stderrWriter();
            try writer.print("gitignore: template name(s) required\n", .{});
            try writer.print("Usage: zuxi gitignore <template1,template2,...>\n", .{});
            try writer.print("Available: {s}\n", .{available_templates});
            return error.MissingArgument;
        }
        try generateGitignore(ctx, inp.data);
    } else {
        const writer = ctx.stderrWriter();
        try writer.print("gitignore: template name(s) required\n", .{});
        try writer.print("Usage: zuxi gitignore <template1,template2,...>\n", .{});
        try writer.print("Available: {s}\n", .{available_templates});
        return error.MissingArgument;
    }
}

fn generateGitignore(ctx: context.Context, input: []const u8) !void {
    const writer = ctx.stdoutWriter();
    var first = true;

    var iter = std.mem.splitScalar(u8, input, ',');
    while (iter.next()) |raw_name| {
        const name = std.mem.trim(u8, raw_name, &std.ascii.whitespace);
        if (name.len == 0) continue;

        if (getTemplate(name)) |tmpl| {
            if (!first) {
                try writer.print("\n", .{});
            }
            try writer.print("# === {s} ===\n", .{name});
            try writer.writeAll(tmpl);
            first = false;
        } else {
            const err_writer = ctx.stderrWriter();
            try err_writer.print("gitignore: unknown template '{s}'\n", .{name});
            try err_writer.print("Available: {s}\n", .{available_templates});
            return error.InvalidArgument;
        }
    }

    if (first) {
        const err_writer = ctx.stderrWriter();
        try err_writer.print("gitignore: no valid template names provided\n", .{});
        return error.InvalidArgument;
    }
}

/// Command definition for registration.
pub const command = registry.Command{
    .name = "gitignore",
    .description = "Generate .gitignore from templates",
    .category = .dev,
    .subcommands = &.{},
    .execute = execute,
};

// --- Tests ---

fn execWithInput(input: ?[]const u8) ![]u8 {
    const allocator = std.testing.allocator;
    const tmp_out = "zuxi_test_gitignore_out.tmp";

    const out_file = try std.fs.cwd().createFile(tmp_out, .{});

    var ctx = context.Context.initDefault(allocator);
    ctx.stdout = out_file;

    if (input) |inp| {
        const arg_list = [_][]const u8{inp};
        ctx.args = &arg_list;
        execute(ctx, null) catch |err| {
            out_file.close();
            std.fs.cwd().deleteFile(tmp_out) catch {};
            return err;
        };
    } else {
        execute(ctx, null) catch |err| {
            out_file.close();
            std.fs.cwd().deleteFile(tmp_out) catch {};
            return err;
        };
    }
    out_file.close();

    const file = try std.fs.cwd().openFile(tmp_out, .{});
    defer file.close();
    defer std.fs.cwd().deleteFile(tmp_out) catch {};
    return try file.readToEndAlloc(allocator, io.max_input_size);
}

test "gitignore go template" {
    const output = try execWithInput("go");
    defer std.testing.allocator.free(output);
    try std.testing.expect(std.mem.indexOf(u8, output, "*.exe") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "vendor/") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "# === go ===") != null);
}

test "gitignore node template" {
    const output = try execWithInput("node");
    defer std.testing.allocator.free(output);
    try std.testing.expect(std.mem.indexOf(u8, output, "node_modules/") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, ".env") != null);
}

test "gitignore python template" {
    const output = try execWithInput("python");
    defer std.testing.allocator.free(output);
    try std.testing.expect(std.mem.indexOf(u8, output, "__pycache__/") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "venv/") != null);
}

test "gitignore rust template" {
    const output = try execWithInput("rust");
    defer std.testing.allocator.free(output);
    try std.testing.expect(std.mem.indexOf(u8, output, "/target/") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "Cargo.lock") != null);
}

test "gitignore zig template" {
    const output = try execWithInput("zig");
    defer std.testing.allocator.free(output);
    try std.testing.expect(std.mem.indexOf(u8, output, "zig-out/") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, ".zig-cache/") != null);
}

test "gitignore combined templates" {
    const output = try execWithInput("go,macos,vscode");
    defer std.testing.allocator.free(output);
    try std.testing.expect(std.mem.indexOf(u8, output, "# === go ===") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "# === macos ===") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "# === vscode ===") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, ".DS_Store") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, ".vscode/*") != null);
}

test "gitignore combined with spaces" {
    const output = try execWithInput("rust, zig");
    defer std.testing.allocator.free(output);
    try std.testing.expect(std.mem.indexOf(u8, output, "# === rust ===") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "# === zig ===") != null);
}

test "gitignore macos template" {
    const output = try execWithInput("macos");
    defer std.testing.allocator.free(output);
    try std.testing.expect(std.mem.indexOf(u8, output, ".DS_Store") != null);
}

test "gitignore windows template" {
    const output = try execWithInput("windows");
    defer std.testing.allocator.free(output);
    try std.testing.expect(std.mem.indexOf(u8, output, "Thumbs.db") != null);
}

test "gitignore linux template" {
    const output = try execWithInput("linux");
    defer std.testing.allocator.free(output);
    try std.testing.expect(std.mem.indexOf(u8, output, ".Trash-*") != null);
}

test "gitignore jetbrains template" {
    const output = try execWithInput("jetbrains");
    defer std.testing.allocator.free(output);
    try std.testing.expect(std.mem.indexOf(u8, output, ".idea/") != null);
}

test "gitignore unknown template returns error" {
    const result = execWithInput("unknown");
    try std.testing.expectError(error.InvalidArgument, result);
}

test "gitignore no input returns error" {
    const allocator = std.testing.allocator;
    const tmp_out = "zuxi_test_gitignore_noinput.tmp";
    const tmp_stdin = "zuxi_test_gitignore_stdin.tmp";
    // Create empty stdin file to avoid blocking on pipe read.
    const sf = try std.fs.cwd().createFile(tmp_stdin, .{});
    sf.close();
    const stdin_rd = try std.fs.cwd().openFile(tmp_stdin, .{});
    const out_file = try std.fs.cwd().createFile(tmp_out, .{});
    var ctx = context.Context.initDefault(allocator);
    ctx.stdout = out_file;
    ctx.stdin = stdin_rd;
    const result = execute(ctx, null);
    stdin_rd.close();
    out_file.close();
    std.fs.cwd().deleteFile(tmp_out) catch {};
    std.fs.cwd().deleteFile(tmp_stdin) catch {};
    try std.testing.expectError(error.MissingArgument, result);
}

test "gitignore command struct fields" {
    try std.testing.expectEqualStrings("gitignore", command.name);
    try std.testing.expectEqual(registry.Category.dev, command.category);
    try std.testing.expectEqual(@as(usize, 0), command.subcommands.len);
}

test "getTemplate returns null for unknown" {
    try std.testing.expect(getTemplate("nonexistent") == null);
}

test "getTemplate returns content for known templates" {
    try std.testing.expect(getTemplate("go") != null);
    try std.testing.expect(getTemplate("node") != null);
    try std.testing.expect(getTemplate("python") != null);
    try std.testing.expect(getTemplate("rust") != null);
    try std.testing.expect(getTemplate("zig") != null);
    try std.testing.expect(getTemplate("macos") != null);
    try std.testing.expect(getTemplate("linux") != null);
    try std.testing.expect(getTemplate("windows") != null);
    try std.testing.expect(getTemplate("vscode") != null);
    try std.testing.expect(getTemplate("jetbrains") != null);
}
